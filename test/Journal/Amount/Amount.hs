module Journal.Amount.Amount (
  amountTestTree
  )where

import Test.Tasty
import Test.Tasty.HUnit
import Plainledger.Journal.Amount
import Plainledger.Error
import qualified Data.Text as T
import Control.Monad.Except
import Plainledger.I18n.I18n

amountDesc = ('.',Nothing,Nothing)
amountDescFull = ('.',Just ',',Just '$')

amountTestTree :: TestTree
amountTestTree =
  testGroup "Amount"
    [ testAmount ["1", "1.0","01", "0","0.0","124.456"],
      okAmount amountDescFull "(1)" (-1),
      okAmount amountDescFull "(123.34e0)" (-123.34),
      okAmount amountDescFull "$ 123" 123,
      okAmount amountDescFull "123.45 $" 123.45,
      okAmount amountDescFull "($ 123.34)" (-123.34),
      okAmount amountDescFull "(123.34$)" (-123.34),
      okAmount amountDescFull "3,456" 3456,
      okAmount amountDescFull "(123,345.34$)" (-123345.34),
      okAmount amountDescFull "123,456" 123456,
      okAmount amountDescFull "123,456,789" 123456789,
      okAmount amountDescFull "(123,345,789.34$)" (-123345789.34),
      koAmount amountDesc "" (mkErrorNoPos $ ParseAmountErr ""),
      koAmount amountDesc "123abc" (mkErrorNoPos $ ParseAmountErr "123abc"),
      koAmount amountDesc "3e-257" (mkErrorNoPos $ ParseAmountExponentErr "3e-257"),
      koAmount amountDesc ".45" (mkErrorNoPos $ ParseAmountErr ".45"),
      koAmount amountDesc "5." (mkErrorNoPos $ ParseAmountErr "5."),
      koAmount amountDesc "1.2e" (mkErrorNoPos $ ParseAmountErr "1.2e"),
      koAmount amountDesc "+" (mkErrorNoPos $ ParseAmountErr "+"),
      koAmount amountDesc "-" (mkErrorNoPos $ ParseAmountErr "-"),
      koAmount amountDesc "e" (mkErrorNoPos $ ParseAmountErr "e"),
      koAmount amountDesc "E" (mkErrorNoPos $ ParseAmountErr "E"),
      koAmount amountDesc "abc" (mkErrorNoPos $ ParseAmountErr "abc"),
      koAmount amountDesc "." (mkErrorNoPos $ ParseAmountErr "."),
      koAmount (',',Nothing,Nothing) "," (mkErrorNoPos $ ParseAmountErr ","),
      koAmount amountDesc "+abc" (mkErrorNoPos $ ParseAmountErr "+abc"),
      koAmount amountDesc "+.45" (mkErrorNoPos $ ParseAmountErr "+.45"),
      koAmount amountDescFull "(" (mkErrorNoPos $ ParseAmountErr "("),
      koAmount amountDescFull ")" (mkErrorNoPos $ ParseAmountErr ")"),
      koAmount amountDescFull "($12" (mkErrorNoPos $ ParseAmountErr "($12"),
      koAmount amountDescFull "$12)" (mkErrorNoPos $ ParseAmountErr "$12)"),
      koAmount amountDescFull "123$.24" (mkErrorNoPos $ ParseAmountErr "123$.24"),
      koAmount amountDescFull "(-1)" (mkErrorNoPos $ ParseAmountErr "(-1)"),
      koAmount amountDescFull "123 456" (mkErrorNoPos $ ParseAmountErr "123 456"),
      koAmount amountDescFull "123.456,789" (mkErrorNoPos $ ParseAmountErr "123.456,789"),
      koAmount amountDescFull ",123.45" (mkErrorNoPos $ ParseAmountErr ",123.45"),
      koAmount amountDescFull "12,3456,789" (mkErrorNoPos $ ParseAmountErr "12,3456,789"),
      koAmount amountDescFull "123,456," (mkErrorNoPos $ ParseAmountErr "123,456,"),
      koAmount amountDescFull "123,456789" (mkErrorNoPos $ ParseAmountErr "123,456789")
    ]

-- Accepts as list of numbers and generate test by
-- also changing the dot for a comma, adding + and - sign
-- and exponentition
testAmount :: [String] -> TestTree
testAmount xs =
  let mkNumber s = [s, 
                    '-' : s, 
                    '+' : s, 
                    s ++ "e2",
                    s ++ "E2",
                    s ++ "e-4",
                    '-' : s ++ "e2",
                    '+' : s ++ "E2",
                    '-' : s ++ "e-4"]
      numbers = concatMap mkNumber xs
      numbersComma = map (map (\c -> if c == '.' then ',' else c)) 
                     numbers
      testsDot = map (\s -> okAmountTest ('.',Nothing,Nothing) s (read s)) numbers
      testsComma = map (\(s, s1) -> okAmountTest (',',Nothing,Nothing) s (read s1)) 
                   $ zip numbersComma numbers
      tests = testsDot ++ testsComma
  in testCase "Autogenerated parsing tests" $ sequence_ tests

okAmountTest :: AmountDescriptor -> String -> Quantity -> IO ()
okAmountTest sep t expectedAmount = do
       account <- runExceptT $ parseAmount sep (T.pack t)
       case account of
         Left err -> assertFailure 
                   $ printErr err
         Right actual -> assertEqual "" expectedAmount actual

okAmount :: AmountDescriptor -> String -> Quantity -> TestTree
okAmount sep t expectedAmount = 
  testCase ("Decode " ++ show t) $ okAmountTest sep t expectedAmount

koAmount :: AmountDescriptor -> String  -> Errors -> TestTree
koAmount sep t expectedErr =
   testCase ("Assert error for " ++ show t) $ do
       account <- runExceptT $ parseAmount sep (T.pack t)
       case account of
         Left actual -> assertEqual "" expectedErr actual
         Right _ -> assertFailure $ "Decoding " ++ t ++ " should throw an error"

printErr :: [Error] -> String
printErr err = T.unpack
                       $ printErrors
                       $ map (i18nText En_CA . TError ) err