module Journal.Amount.Amount (
  amountTestTree
  )where

import Test.Tasty
import Test.Tasty.HUnit
import Plainledger.Journal.Amount
import Plainledger.Error
import qualified Data.Text as T
import Control.Monad.Except


amountTestTree :: TestTree
amountTestTree =
  testGroup "Amount"
    [ testAmount ["1", "1.0","01", "0","0.0","124.456"],

      koAmount '.' "" (mkErrorNoPos $ ParseAmountErr ""),
      koAmount '.' "3e-257" (mkErrorNoPos $ ParseAmountExponentErr "3e-257"),
      koAmount '.' ".45" (mkErrorNoPos $ ParseAmountErr ".45"),
      koAmount '.' "5." (mkErrorNoPos $ ParseAmountErr "5."),
      koAmount '.' "1.2e" (mkErrorNoPos $ ParseAmountErr "1.2e"),
      koAmount '.' "+" (mkErrorNoPos $ ParseAmountErr "+"),
      koAmount '.' "-" (mkErrorNoPos $ ParseAmountErr "-"),
      koAmount '.' "e" (mkErrorNoPos $ ParseAmountErr "e"),
      koAmount '.' "E" (mkErrorNoPos $ ParseAmountErr "E"),
      koAmount '.' "abc" (mkErrorNoPos $ ParseAmountErr "abc"),
      koAmount '.' "." (mkErrorNoPos $ ParseAmountErr "."),
      koAmount ',' "," (mkErrorNoPos $ ParseAmountErr ","),
      koAmount '.' "+abc" (mkErrorNoPos $ ParseAmountErr "+abc"),
      koAmount '.' "+.45" (mkErrorNoPos $ ParseAmountErr "+.45")
    ]

-- Accepts as list of numbers and generate test by
-- also changing the dot for a comma, adding + and - sign
-- and exponentition
testAmount :: [String] -> TestTree
testAmount xs =
  let mkNumber s = [s, 
                    '-' : s, 
                    '+' : s, 
                    s ++ "e2",
                    s ++ "E2",
                    s ++ "e-4",
                    '-' : s ++ "e2",
                    '+' : s ++ "E2",
                    '-' : s ++ "e-4"]
      numbers = concatMap mkNumber xs
      numbersComma = map (map (\c -> if c == '.' then ',' else c)) 
                     numbers
      testsDot = map (\s -> okAmountTest '.' s (read s)) numbers
      testsComma = map (\(s, s1) -> okAmountTest ',' s (read s1)) 
                   $ zip numbersComma numbers
      tests = testsDot ++ testsComma
  in testCase "Autogenerated parsing tests" $ sequence_ tests

okAmountTest :: Char -> String -> Quantity -> IO ()
okAmountTest sep t expectedAmount = do
       account <- runExceptT $ parseAmount sep (T.pack t)
       case account of
         Left err -> assertFailure $ printErrors err
         Right actual -> assertEqual "" expectedAmount actual

-- okAmount :: Char -> String -> Quantity -> TestTree
-- okAmount sep t expectedAmount = 
--   testCase ("Decode " ++ show t) $ okAmountTest sep t expectedAmount

koAmount :: Char -> String  -> Errors -> TestTree
koAmount sep t expectedErr =
   testCase ("Assert error for " ++ show t) $ do
       account <- runExceptT $ parseAmount sep (T.pack t)
       case account of
         Left actual -> assertEqual "" expectedErr actual
         Right _ -> assertFailure $ "Decoding " ++ t ++ " should throw an error"
