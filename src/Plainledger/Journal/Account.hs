-- |
-- Module      :  Plainledger.Journal.Account
-- Copyright   :  Â© 2020 Vincent Archambault
-- License     :  0BSD
--
-- Maintainer  :  Vincent Archambault <archambault.v@gmail.com>
-- Stability   :  experimental
--
-- This module defines the account data type.

module Plainledger.Journal.Account
(
  AccountF(..),
  JAccount,
  Account,
  ChartOfAccounts,
  chartToList,
  decodeAccounts,
  validateAccounts,
  -- accountsToHashMap,
  decodeAccountsFile,
  AccountType(..),
  decodeAccountType,
  accountTypeId,
  isBalanceSheetType,
  isIncomeStatementType,
  isCreditType,
  isDebitType,
  )
where

import System.FilePath
import Data.Char (ord)
import Data.Function
import Control.Monad.Except
import qualified Data.ByteString as BS
import qualified Data.ByteString.Lazy as BL
import Data.ByteString.Lazy (ByteString)
import Data.List hiding (group, lines)
import Plainledger.I18n.I18n
import Plainledger.Error
import Plainledger.Internal.Csv
import Plainledger.Internal.Utils
import Prelude hiding (lines)
import qualified Data.Csv as C
import qualified Data.Text as T
import qualified Data.Vector as V
import qualified Data.HashMap.Strict as M
import Data.Tree
import Data.Hashable ( Hashable(hashWithSalt) )

-- | The top level grouping of an account. Must be Asset, Liability,
-- Equity, Revenue or Expense.
data AccountType = Asset
                | Liability
                | Equity
                | Revenue
                | Expense
                deriving (Show, Eq, Ord)

accountTypeId :: AccountType -> Int
accountTypeId Asset = 1
accountTypeId Liability = 2
accountTypeId Equity = 3
accountTypeId Revenue = 4
accountTypeId Expense = 5

i18nAccountType :: Language -> [T.Text]
i18nAccountType lang = [i18nText lang TAsset,
                        i18nText lang TLiability,
                        i18nText lang TEquity,
                        i18nText lang TRevenue,
                        i18nText lang TExpense]

decodeAccountType :: Language -> T.Text -> Maybe AccountType
decodeAccountType lang x | x == i18nText lang TAsset = return Asset
decodeAccountType lang x | x == i18nText lang TLiability = return Liability
decodeAccountType lang x | x == i18nText lang TEquity = return Equity
decodeAccountType lang x | x == i18nText lang TRevenue = return Revenue
decodeAccountType lang x | x == i18nText lang TExpense = return Expense
decodeAccountType _ _ = Nothing

isBalanceSheetType :: AccountType -> Bool
isBalanceSheetType a = a `elem` [Asset, Liability, Equity]

isIncomeStatementType :: AccountType -> Bool
isIncomeStatementType = not . isBalanceSheetType

isCreditType :: AccountType -> Bool
isCreditType a = a `elem` [Liability, Equity, Revenue]

isDebitType :: AccountType -> Bool
isDebitType = not . isCreditType

data AccountF t = Account {
  aId :: Int, -- Generated by the program, not the user. Number 1 to 5 corresponds
              -- to the fire AccountType
  aIdentifier :: T.Text, -- Unique to each account. Used in the CSV files
  aDisplayName :: T.Text, -- Many accounts can have the same display name
  aNumber :: Int, -- Provided by the user
  aParent :: T.Text, -- Identifier of the parent, as defined in the account CSV files
  aAccountType :: t -- The account type of the account. This property is not known when
                    -- parsing the accounts file.
}
  deriving (Show)

type JAccount = AccountF ()
type Account = AccountF AccountType

instance Eq Account where
  a1 == a2 = aId a1 == aId a2

instance Hashable Account where
  hashWithSalt k a = hashWithSalt k (aId a)

instance Ord Account where
  compare a1 a2 = compare (aId a1) (aId a2)

type ChartOfAccounts = [Tree Account]

chartToList :: ChartOfAccounts -> [Account]
chartToList [] = []
chartToList (x:xs) = treeToList x ++ chartToList xs
  where treeToList (Node y ys) = y : concatMap treeToList ys

-- accountsToHashMap :: [Account] -> HashMap T.Text Account
-- accountsToHashMap = HM.fromList . map (\a -> (aId a, a))

validateAccounts :: (MonadError Errors m) =>
                    T.Text ->
                    T.Text ->
                    Language ->
                    [(SourcePos, JAccount)] ->
                    m ChartOfAccounts
validateAccounts openingAccount earningAccount lang accounts = do
  validateAccountIdentNonNull accounts
  validateAccountIdentNoDup accounts
  validateOpeningBalanceAccount accounts openingAccount
  validateEarningsAccount accounts earningAccount
  validateParentAccount accounts lang
  makeChartOfAccounts lang accounts


validateAccountIdentNonNull :: (MonadError Errors m) =>
                            [(SourcePos, JAccount)] ->
                            m ()
validateAccountIdentNonNull accounts =
  let nullId :: [(SourcePos, T.Text)]
      nullId = filter (T.null . snd)
             $ map (fmap aIdentifier) accounts
  in if null nullId
     then return ()
     else throwError
          $ mkErrorMultiPos (map fst nullId)
            ZeroLengthAccountId

validateAccountIdentNoDup :: (MonadError Errors m) =>
                      [(SourcePos, JAccount)] ->
                      m ()
validateAccountIdentNoDup accounts =
  let dup :: [[(SourcePos, T.Text)]]
      dup = filter (not . null . tail)
          $ groupBy ((==) `on` snd)
          $ sortBy (compare `on` snd)
          $ map (fmap aIdentifier) accounts
      mkErr ls = mkErrorMultiPos (map fst ls)
                 (DuplicateAccountId $ T.unpack $ snd $ head ls)
  in if null dup
     then return ()
     else throwError $ concatMap mkErr dup

validateOpeningBalanceAccount :: (MonadError Errors m) =>
                           [(SourcePos, JAccount)] ->
                           T.Text ->
                           m ()
validateOpeningBalanceAccount accounts openingAccount =
  if openingAccount `elem` map (aIdentifier . snd) accounts
  then return ()
  else throwError
       $ mkErrorNoPos
       $ OpeningBalanceNotDefined
       $ T.unpack openingAccount

validateEarningsAccount :: (MonadError Errors m) =>
                           [(SourcePos, JAccount)] ->
                           T.Text ->
                           m ()
validateEarningsAccount accounts earningAccount =
  if earningAccount `elem` map (aIdentifier . snd) accounts
  then return ()
  else throwError
       $ mkErrorNoPos
       $ EarningsAccountNotDefined
       $ T.unpack earningAccount

validateParentAccount :: (MonadError Errors m) =>
                         [(SourcePos, JAccount)] ->
                         Language ->
                         m ()
validateParentAccount accounts lang =
  let accs = map snd accounts
      parents = i18nAccountType lang ++ map aIdentifier accs
      invalid = filter snd
              $ map (\(pos, a) -> ((pos, a), aParent a `elem` parents)) accounts
      mkErr :: ((SourcePos, JAccount), b) -> Errors
      mkErr ((pos, a), _) = let aIdent = T.unpack $ aIdentifier a
                                aPar = T.unpack $ aParent a
                                err = InvalidParent aIdent aPar
                            in mkError pos err
  in if null invalid
     then return ()
     else throwError $ concatMap mkErr invalid

makeChartOfAccounts :: (MonadError Errors m) =>
                        Language ->
                        [(SourcePos, JAccount)] ->
                        m ChartOfAccounts
makeChartOfAccounts lang accounts =
  -- We build the tree bottom up, starting with the children.
  -- To detect cycles, we use a set of available parents and remove a parent
  -- from this set once it is in the tree. This way if a cycle happens, the parent won't be
  -- in the set the second time we want to add it to the tree.
  let -- We first set Asset as a dummy account type
      accs :: [Account]
      accs = map ((\a -> a{aAccountType = Asset}) . snd) accounts
      parentsMap = M.fromList $ map (\a -> (aParent a, a)) accs
      children :: [Account]
      children = filter (\a -> not $ M.member (aIdentifier a) parentsMap) accs
      childrenTree :: [Tree Account]
      childrenTree = map (`Node` []) children
      chart :: [Tree Account]
      chart = makeChart parentsMap childrenTree
  in return $ map (\a -> populateAccountType (aAccountType $ rootLabel a) a) chart

  where makeChart :: M.HashMap T.Text Account -> [Tree Account] -> [Tree Account]
        makeChart p c =
          let -- Group the children by parent
              cs :: [[Tree Account]]
              cs = groupBy ((==) `on` aParent . rootLabel)
                 $ sortOn (aParent . rootLabel) c
              -- For each group create a parent node
              xs :: [Tree Account]
              xs = map (\ls -> Node (makeParent (aParent $ rootLabel $ head ls)) ls) cs

              makeParent :: T.Text -> Account
              makeParent x =
                case decodeAccountType lang x of
                  Nothing -> p M.! x
                  Just aType -> Account (accountTypeId aType) "" x 0 "" aType

              -- Remove the new parents from the list
              p' :: M.HashMap T.Text Account
              p' = foldl (\p1 a1 -> M.delete (aIdentifier $ rootLabel a1) p1) p xs
          in makeChart p' xs

        populateAccountType :: AccountType -> Tree Account -> Tree Account
        populateAccountType accType (Node x xs) = 
          let xs' = map (populateAccountType accType) xs
          in Node x{aAccountType = accType} xs'

-- | The first line is the header
decodeAccounts :: forall m . (MonadError Errors m)
               => Language -> Char -> ByteString -> m [JAccount]
decodeAccounts lang csvSeparator bs = do
  -- Read the CSV file as vector of T.Text
  let opts = C.defaultDecodeOptions {
                C.decDelimiter = fromIntegral (ord csvSeparator)
                }
  csv <- either (throwError . mkErrorNoPos . ErrorMessage) return
      $ C.decodeWith opts C.NoHeader bs

  -- Decode the header to know the index of columns
  let myFilter t = t `elem` [i18nText lang TAccountIdent,
                             i18nText lang TAccountName,
                             i18nText lang TAccountNumber,
                             i18nText lang TAccountParent]
  (csvData, indexes) <- processColumnIndexes csv myFilter

  identIdx <- columnIndex indexes (i18nText lang TAccountIdent)
  numberIdx <- columnIndex indexes (i18nText lang TAccountNumber)
  parentIdx <- columnIndex indexes (i18nText lang TAccountParent)
  let nameIdx = optionalColumnIndex indexes (i18nText lang TAccountName)

 -- Add row information to the CSV line
  let csvWithRowNumber = zip [2..] $ V.toList csvData

  -- Function to parse a line into an Account 
  -- We use the row number as the unique id for the account                          
  let parseLine (row, line) =
        let p = do
              ident <- columnData identIdx line
              name <- optionalColumnData ident nameIdx line
              number <- columnDataM numberIdx line parseInt
              parent <- columnData parentIdx line
              -- The first 5 id number are reserved for the top five accounts
              return $ Account (row + 5) ident name number parent ()
        in p `catchError` (throwError . setSourcePosRowIfNull row)

  accs <- mapM parseLine csvWithRowNumber

  -- Fill DisplayName if it was missing
  let accWithNames = map
                     (\a -> if T.null (aDisplayName a) then a{aDisplayName = aIdentifier a} else a)
                     accs
  return accWithNames

decodeAccountsFile :: Language -> FilePath -> Char -> ExceptT Errors IO  [(SourcePos, JAccount)]
decodeAccountsFile lang filePath csvSeparator =
  withExceptT (setSourcePosFileIfNull filePath) $ do
      csvBS <- fmap (snd . removeBom) $ liftIO $ BS.readFile filePath
      accs <- decodeAccounts lang csvSeparator (BL.fromStrict csvBS)
      let pos = map (\i -> SourcePos filePath i 0) [2..]
      return $ zip pos accs
